---
description: 
globs: 
alwaysApply: true
---
- Ensure UI elements are large enough for easy interaction on touch devices

- *Responsive and adaptive:*
  - Design UI capable of adapting to different screen sizes
  - Ensure consistent user experience on both phones and tablets
  - Use relative units (%, dp, sp) rather than fixed units

## 5. API Integration and Management
- *API service architecture:*
  - Create and maintain separate API services for each function or module
  - Apply appropriate design patterns (Repository, Factory, Singleton, etc.)
  - Structure code by layers: Service, Repository, Model
  - Clear separation between data processing logic and display logic

- *Request and response handling:*
  - Handle all states thoroughly: loading, success, error, empty
  - Apply appropriate retry mechanisms for unstable requests
  - Implement reasonable data caching to minimize the number of requests
  - Ensure elegant error handling and notify users when necessary

- *Security and performance:*
  - Follow security principles when working with APIs
  - Optimize payload size to improve performance
  - Use authentication methods that comply with backend requirements
  - Implement cancellation tokens for requests that are no longer needed

## 6. State Management and Data Flow
- *Effective state management:*
  - Use state management solutions appropriate for the project (Redux, MobX, Context API, etc.)
  - Avoid storing duplicate states
  - Normalize data for easy access and updates
  - Apply immutable models when necessary to avoid side effects

- *Render optimization:*
  - Use memoization to avoid unnecessary renders
  - Apply hooks like useMemo, useCallback appropriately
  - Break down components to minimize unnecessary re-renders
  - Use react-window or recyclerlistview for long lists

## 7. Knowledge Management and Documentation
- *Research documentation system:*
  - Create and maintain markdown files in the docs/ directory
  - Categorize documentation by function or module
  - Use clear, descriptive file names (e.g., authentication-flow.md, data-caching-strategy.md)
  - Use clear structure with sections and subsections marked by heading levels

- *Research documentation content:*
  - Clearly describe the problem or technical challenge
  - List considered solutions along with their pros and cons
  - Explain in detail the chosen solution and the reasons
  - Include sample code snippets or illustrative diagrams when necessary
  - List references or related documents

- *Documentation updates and maintenance:*
  - Update documentation when changes occur in solutions or approaches
  - Clearly note creation and update dates
  - Version documents if necessary
  - Ensure searchability by using appropriate keywords

## 8. Quality Assurance Principles
- *Code quality:*
  - Follow SOLID, DRY, and KISS principles
  - Handle edge cases thoroughly
  - Avoid "magic numbers" and "magic strings"
  - Use comments appropriately to explain complex logic
Cây ATM
- Ensure UI elements are large enough for easy interaction on touch devices

- *Responsive and adaptive:*
  - Design UI capable of adapting to different screen sizes
  - Ensure consistent user experience on both phones and tablets
  - Use relative units (%, dp, sp) rather than fixed units

## 5. API Integration and Management
- *API service architecture:*
  - Create and maintain separate API services for each function or module
  - Apply appropriate design patterns (Repository, Factory, Singleton, etc.)
  - Structure code by layers: Service, Repository, Model
  - Clear separation between data processing logic and display logic

- *Request and response handling:*
  - Handle all states thoroughly: loading, success, error, empty
  - Apply appropriate retry mechanisms for unstable requests
  - Implement reasonable data caching to minimize the number of requests
  - Ensure elegant error handling and notify users when necessary

- *Security and performance:*
  - Follow security principles when working with APIs
  - Optimize payload size to improve performance
  - Use authentication methods that comply with backend requirements
  - Implement cancellation tokens for requests that are no longer needed

## 6. State Management and Data Flow
- *Effective state management:*
  - Use state management solutions appropriate for the project (Redux, MobX, Context API, etc.)
  - Avoid storing duplicate states
  - Normalize data for easy access and updates
  - Apply immutable models when necessary to avoid side effects

- *Render optimization:*
  - Use memoization to avoid unnecessary renders
  - Apply hooks like useMemo, useCallback appropriately
  - Break down components to minimize unnecessary re-renders
  - Use react-window or recyclerlistview for long lists

## 7. Knowledge Management and Documentation
- *Research documentation system:*
  - Create and maintain markdown files in the docs/ directory
  - Categorize documentation by function or module
  - Use clear, descriptive file names (e.g., authentication-flow.md, data-caching-strategy.md)
  - Use clear structure with sections and subsections marked by heading levels

- *Research documentation content:*
  - Clearly describe the problem or technical challenge
  - List considered solutions along with their pros and cons
  - Explain in detail the chosen solution and the reasons
  - Include sample code snippets or illustrative diagrams when necessary
  - List references or related documents

- *Documentation updates and maintenance:*
  - Update documentation when changes occur in solutions or approaches
  - Clearly note creation and update dates
  - Version documents if necessary
  - Ensure searchability by using appropriate keywords

## 8. Quality Assurance Principles
- *Code quality:*
  - Follow SOLID, DRY, and KISS principles
  - Handle edge cases thoroughly
  - Avoid "magic numbers" and "magic strings"
  - Use comments appropriately to explain complex logic
Cây ATM
- Ensure code is readable and maintainable

## 9. Performance Optimization
- *Application performance:*
  - Optimize application startup time
  - Minimize resource usage (CPU, RAM)
  - Optimize animations and transitions
  - Implement lazy loading for components not immediately needed

- *Bundle size optimization:*
  - Use tree shaking when importing libraries
  - Avoid importing entire large libraries when only a few components are needed
  - Split code by route or feature when necessary
  - Use dynamic imports for infrequently used features

## 10. Code Review Guidelines
- *Evaluation criteria:*
  - Correctness: Does the code fulfill the requirements correctly?
  - Efficiency: Is it optimized for performance and resources?
  - Maintainability: Is the code readable and easy to maintain?
  - Consistency: Does the code follow the current style and structure?
  - Extensibility: Is the code easily expandable in the future?

- *Review process:*
  - Understand the requirements and purpose of the code
  - Review each file systematically
  - Provide specific and constructive feedback
  - Suggest improvements when necessary
  - Distinguish clearly between serious issues and minor suggestions

## 11. Local Data Handling
- *Local storage:*
  - Use AsyncStorage, SecureStore, SQLite, or Realm according to requirements
  - Encrypt sensitive data
  - Apply data synchronization mechanisms when necessary
  - Efficiently handle large data sets

- *Cache memory management:*
  - Establish appropriate caching strategies
  - Apply invalidation and expiration mechanisms for cached data
  - Prioritize performance vs. freshness according to specific requirements

  - Handle offline mode elegantly